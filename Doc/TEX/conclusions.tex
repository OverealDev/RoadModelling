

Two approaches to build roads have been handled this coursework. the first one allows the user to generate roads with circles in input. The sign of radiuses determines the orientation of turns, and the algorithm is such that all combinaison of turns are possible (included overlapping roads). However, the user has to specifiy manually some additionnal residual necessary information to draw straight portions (to choose which pair of inner-outer tangent to consider) because I coulndn't find a way to automate it. This method of building roads is convenient to modify already generated roads by the latter method, but not so much to actually generating it. The second approach is using directions and lengths as input. This version is functional and turns in both direction are possible. This approach is more local than the previous one and gives more control for the user : it's easier to create a road since the building process is chronologically in the same order as the travel order. In other words, the process is more natural.
\newline
A potential feature that could be added is the data translation from a road built by the second approach to the same road but build by the first approach. That would make both approaches complementary, since roadConstructor2() is more convenient to generate roads and rodConstructor1() to modify them.
Then, I tried to implement a inverse-engineering protocol whose goal was to detect "straight and curve portions of road" among sampled data. My hope was to be able to generate a road akin to the road that have been sampled. "the straight detector" gives very approximate results and sampled data have to be really good and full. The "curve detector" hasn't been implemented.
\newline
During this project, I used Python, which allows me to consolidate my knowledge in that language. I feel better at coding my ideas when it comes to linear algebra. I liked working in this project, even though time was sometimes short. Buvo malonu.
